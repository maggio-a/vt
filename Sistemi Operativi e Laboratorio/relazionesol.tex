\documentclass[11pt,oneside,a4paper]{article}
%\documentclass[10pt,twocolumn,a4paper]{article}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}

\title{Progetto didattico -- Sistemi Operativi}
\author{Andrea Maggiordomo \\ Informatica applicata -- Università di Pisa}
\date{2013}

\begin{document}
\maketitle

%\section{Introduzione}
\begin{abstract}
Questo documento descrive gli aspetti rilevanti della realizzazione del progetto didattico \texttt{fats} per il corso di Sistemi Operativi e Laboratorio e costituisce, insieme ai commenti al codice, la documentazione del sistema realizzato. La sezione \ref{sec:spec} tratta delle specifiche implementate dal sistema, mentre la sezione \ref{sec:files} illustra l'organizzazione dei file consegnati e la sezione \ref{sec:lib} menziona brevemente alcuni aspetti relativi all'implementazione della libreria. Le sezioni \ref{sec:create}, \ref{sec:server}, e \ref{sec:client} documentano rispettivamente il funzionamento del comando per la formattazione di un file system, del server e del client: particolare attenzione è rivolta alla descrizione dell'architettura del server, che si è rivelata la componente del sistema più complessa da realizzare. La sezione \ref{sec:comp} illustra il processo di compilazione e l'esecuzione dei semplici test implementati.
\end{abstract}

\section{Specifiche del sistema}
\label{sec:spec}
Argomento del progetto didattico di sistemi operativi è lo sviluppo di un sistema software che gestisca un file system attraverso un'architettura di tipo client-server. Il sistema deve operare su dispositivi virtuali memorizzati come comuni file Unix; nel resto del documento i termini \emph{dispositivo} o \emph{device} verranno usati con riferimento a questi file.

Le specifiche del progetto prevedono un insieme di funzionalità di base la cui implementazione è obbligatoria, e la possibilità di estendere il sistema con alcune funzionalità avanzate. La soluzione proposta implementa oltre alle funzionalità di base anche quelle descritte nella sezione 10 della specifica: realizza cioè un ambiente multi-utente nel quale il server gestisce un insieme di dispositivi, ciascuno assegnato ad un proprietario. I client si identificano con un nome utente e hanno la possibilità di scegliere il dispositivo con cui interfacciarsi. Il sistema prescrive che un client possa operare solo su un file system che abbia come proprietario il nome utente dichiarato.

Per realizzare questa caratteristica è stata modificata la libreria \texttt{fats} in modo da associare un utente ad ogni device: la scelta è stata quella di aggiungere alla struttura che definisce il boot sector il campo \texttt{usr} dove memorizzare il nome del proprietario
\begin{verbatim}
  #define FAT_MAXUSRLEN 16

  struct boot_sector {
    char fs_type;
    int block_size;
    unsigned int num_block;
    char usr[FAT_MAXUSRLEN];
  };
\end{verbatim}
In questo modo è possibile associare un utente al file system quando si effettua il mounting (cioè quando il server carica le informazioni di controllo).

Il server è realizzato con un'architettura multi-thread per permettere la gestione di molteplici file system e conversazioni contemporaneamente. Sono inoltre stati definiti opportuni meccanismi di sincronizzazione per evitare interferenze in caso di accessi concorrenti allo stesso device.

La API utilizzata per la programmazione multi-thread è quella definita dallo standard POSIX (Pthreads).

\section{Organizzazione dei file}
\label{sec:files}
La root directory del progetto contiene il Makefile ed il file \texttt{README}.

I file sorgente risiedono nella cartella \texttt{src} e sono raggruppati tenendo conto delle componenti del sistema che realizzano: le cartelle \texttt{client}, \texttt{server} e \texttt{create} contengono i file relativi all'implementazione degli omonimi moduli; in \texttt{common} sono implementate le funzionalità condivise da client e server (in realtà solo il controllo sulla validità sintattica dei percorsi); \texttt{fat} ospita le definizioni relative al file system e l'implementazione delle operazioni mentre \texttt{com} contiene l'implementazione delle funzioni per la comunicazione tra processi definite dalla libreria.

La cartella \texttt{tmp} ospita a runtime il socket di ascolto del server come da specifica, mentre la cartella \texttt{test} contiene alcuni file utilizzati per verificare automaticamente il funzionamento del sistema (vd. sezione \ref{sec:comp}).

\section{Implementazione della libreria}
\label{sec:lib}
Le funzioni per la comunicazione tra processi sono sostanzialmente dei wrapper per le analoghe chiamate di sistema Unix (\texttt{socket} e \texttt{bind}, \texttt{accept}, \texttt{connect}), e due funzioni specializzate per lo scambio di oggetti \texttt{message\_t} attraverso i socket, basate su \texttt{read} e \texttt{write}.

Per quanto riguarda l'implementazione delle operazioni sul file system \texttt{fats}, trattarne in maniera discorsiva risulta difficile e si rimanda pertanto al codice, che è opportunamente commentato. La navigazione del file system usando i riferimenti parent (specificare percorsi del tipo \texttt{/dir1/../dir2} per indicare \texttt{/dir2}) dovrebbe essere pienamente supportata.

\section{Formattazione dei dispositivi}
\label{sec:create}
La sintassi del comando per la formattazione dei dispositivi è modificata per accomodare la gestione degli utenti con l'aggiunta del parametro \texttt{usr} che dichiara il proprietario del file system
\begin{center}
\texttt{fats\_create usr name nblocks size}
\end{center}

La formattazione di un dispositivo è estremamente semplice: viene compilato il boot sector con le informazioni specificate, costruita la FAT (un array di \texttt{unsigned int} con \texttt{nblocks} elementi) e la directory table per la cartella di root (che inizialmente occupa un solo blocco con le entry ``\texttt{.}'' e ``\texttt{..}''). Sul file designato come dispositivo viene scritto inizialmente il boot sector, successivamente la FAT con tutti gli indici eccetto il primo inizializzati a \texttt{BLOCK\_FREE} ed infine la data region composta dal primo blocco che contiene la directory table della cartella di root e \texttt{nblocks-1} blocchi vuoti.

\section{Il processo server}
\label{sec:server}
Il server viene lanciato con il comando
\begin{center}
\texttt{fats\_server fsdir}
\end{center}
dove \texttt{fsdir} indica la cartella dalla quale caricare i dispositivi.

Il funzionamento del server è relativamente semplice: in fase di avvio indicizza i dispositivi contenuti in \texttt{fsdir}; successivamente attende le richieste di connessione da parte dei client. Il protocollo di comunicazione prevede un handshake a due vie nel quale il client invia una richiesta di connessione al server specificando un nome utente (e opzionalmente il nome di un particolare device richiesto); il server accetta la sessione e la affida ad un thread dedicato soltanto se trova un device associato all'utente, oppure se il device richiesto esplicitamente esiste ed è associato al nome utente specificato.

\subsection{Gestione dei dispositivi}
Quando un device viene caricato, il server inizializza alcune informazioni di supporto; queste sono raggruppate in una struttura apposita
\begin{verbatim}
  struct file_handle {
    char *name;
    FILE *fs;
    struct fat_ctrl fsctrl;
    int num_readers;
    pthread_mutex_t num_mutex;
    pthread_mutex_t write_mutex;
  };
\end{verbatim}
Il campo \texttt{name} denota il nome del file fisico con cui è realizzato il device; i campi \texttt{fs} e \texttt{fsctrl} memorizzano le informazioni di controllo relative al file system (puntatore al dispositivo e metadati); i campi \texttt{num\_readers}, \texttt{num\_mutex}, \texttt{write\_mutex} sono utilizzati per regolare gli accessi concorrenti al dispositivo, e verranno menzionati nella sezione dedicata. Intuitivamente, utilizzare una struttura di questo tipo permette di tenere facilmente traccia di tutte le informazioni necessarie ad un thread per accedere e operare su un file system.

I \texttt{file\_handle} relativi ai file system controllati dal server vengono memorizzati in una tabella con visibilità globale \texttt{fstab} che viene inizializzata durante la fase di indicizzazione ed è rappresentata con la struttura
\begin{verbatim}
  struct fstab_st {
    int numfiles;
    int tabsize;
    struct file_handle *fsystem;
  };
\end{verbatim}
dove \texttt{fsystem} è un puntatore ad un array di \texttt{file\_handle} il cui ultimo elemento ha indice \texttt{numfiles-1}. Gli elementi della tabella vengono riempiti mano a mano che il server esamina le entry di \texttt{fsdir} e la dimensione effettiva dell'array (salvata in \texttt{tabsize}) è estesa dinamicamente quando necessario.

\subsection{Threads}
La funzione \texttt{main} del server (thread principale) è composta sostanzialmente da un ciclo infinito che attende le richieste di connessione da parte dei client sul socket del server. Quando un client si connette e completa l'handshake viene creato un nuovo thread \texttt{client\_handler} (\emph{worker}) che prende in gestione la conversazione mentre \texttt{main} rimane in ascolto di nuove richieste. I thread worker ricevono come argomento il puntatore ad una struttura \texttt{th\_info} che contiene le informazioni necessarie per proseguire la conversazione con il client ed eseguire le operazioni
\begin{verbatim}
  struct th_info_st {
    pthread_t tid;
    channel_t client_c;
    struct file_handle *handle;
    struct th_info_st *next;
  };
  typedef struct th_info_st th_info;
\end{verbatim}
Il campo \texttt{client\_c} denota il descrittore del socket di comunicazione con il client, mentre \texttt{handle} punta al \texttt{file\_handle} per il dispositivo richiesto. Poiché per implementare la terminazione asincrona del server si è reso necessario tenere traccia degli identificatori di tutti i \texttt{client\_handler} attivi, gli oggetti di questo tipo vengono salvati in una lista globale: \texttt{tid} contiene l'identificatore del thread creato e il campo \texttt{next} punta all'elemento successivo nella lista. Il tipo di dato lista di thread è definito ed implementato nei file \texttt{thlist.h} e \texttt{thlist.c} (situati nella cartella \texttt{src/server}).

I thread \texttt{client\_handler} ciclano indefinitamente in attesa dei comandi inviati dai client. Quando un client interrompe la conversazione, il thread rimuove la propria entry dalla lista dei thread attivi e termina l'esecuzione.

\subsection{Gestione della concorrenza}
Nella fase di indicizzazione viene compilata la tabella dei file system \texttt{fstab} con gli opportuni \texttt{file\_handle}: ad ogni file system vengono associati un puntatore al dispositivo fisico ed una struttura di controllo che contiene la relativa tabella di allocazione. Per permettere a più client di interagire con lo stesso file system, è necessario che queste informazioni siano condivise dai thread e possono quindi verificarsi \emph{race conditions} tra i \texttt{client\_handler} che vogliono accedervi.

Il meccansimo di gestione della concorrenza prevede di dividere le operazioni offerte dal file system in operazioni di lettura (\texttt{ls}, \texttt{fread}) e scrittura (\texttt{mkdir}, \texttt{mkfile}, \texttt{append}, \texttt{cp}): l'osservazione è che gli accessi concorrenti in lettura non causano interferenze tra loro, mentre gli accessi in scrittura devono essere esclusivi dal momento che modificano il contenuto del dispositivo fisico e la tabella di allocazione. Questo problema di sincronizzazione (problema dei lettori-scrittori) è risolto con un semplice algoritmo che tiene traccia dei tipi di accesso al dato condiviso: la lock di lettura può essere acquisita da molteplici operazioni mentre quella di scrittura è esclusiva. Per impedire letture e scritture contemporanee, la lock di scrittura viene acquisita dalla prima operazione di lettura che accede al dato, e viene rilasciata dall'ultima operazione di lettura attiva che si conclude: in questo modo non è mai disponibile se ci sono dei lettori attivi, ed in caso di scrittura in corso un eventuale lettore rimane bloccato in attesa di acquisirla.

Questa politica di accesso ai dati è realizzata mantenendo per ogni device un contatore dei lettori attivi (il cui incremento/decremento è protetto da un \texttt{mutex}) ed un secondo \texttt{mutex} per proteggere gli accessi in scrittura; tali informazioni sono memorizzate come campi della struttura \texttt{file\_handle}. Il meccanismo per acquisire i lock di lettura e scrittura è codificato attraverso le procedure \texttt{read\_lock}, \texttt{read\_unlock}, \texttt{write\_lock}, \texttt{write\_unlock} che ricevono come parametro il riferimento ad un \texttt{file\_handle}. L'algoritmo implementato rende le operazioni di scrittura soggette a \emph{starvation}.

\subsection{Terminazione asincrona}
Tra le specifiche del progetto è richiesta la possibilità di terminare il server in maniera asincrona durante l'esecuzione inviando un segnale opportuno (\texttt{SIGINT} o \texttt{SIGTERM}): il server deve portare a termine le eventuali richieste pendenti, terminare le conversazioni con i client ancora connessi ed interrompere l'esecuzione.

L'aspetto problematico di tale caratteristica risiede nel fatto che le funzioni per la comunicazione tra client e server (richieste di connessione e I/O sui socket) incapsulano chiamate di sistema bloccanti (\texttt{accept}, \texttt{read}, \texttt{write}).

Gestire la terminazione asincrona con un semplice signal handler che disattiva un flag globale -- usato come protezione dei cicli di accettazione delle nuove connessioni e delle conversazioni con i client -- comporta che la guardia non venga esaminata fino alla successiva iterazione, dal momento che i thread si sospendono sulle funzioni di cui sopra. Questo violerebbe la specifica di portare a compimento le sole richieste pendenti: il server dovrebbe invece interrompere le conversazioni momentaneamente ``inattive'' che causano la sospensione di alcuni \texttt{client\_handler}. Inoltre, terminare i thread direttamente da un signal handler è una soluzione difficilmente gestibile: i segnali sono intercettati in maniera completamente asincrona, e terminare un thread quando un mutex non è stato rilasciato o parte delle operazioni sul file system non sono state completate può causare lo stallo del server o la corruzione del device in uso.

La soluzione adottata è stata quella di ricorrere alla cancellazione dei thread attivi. Questa scelta risolve infatti il problema delle system call bloccanti: \texttt{accept}, \texttt{read} e \texttt{write} sono definite dallo standard POSIX come \emph{cancellation point}, e la cancellazione di un thread sospeso su una di queste chiamate viene eseguita immediatamente. A ciò si aggiunge il fatto che un thread può temporaneamente ignorare le richieste di cancellazione se ad esempio si trova ad eseguire una sequenza di operazioni durante la quali non deve essere interrotto
\begin{verbatim}
  pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
  /* sezione critica */
  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &state);
\end{verbatim}
In questo caso le richieste vengono esaminate solamente dopo che la cancellazione è stata riabilitata.

Nel codice proposto i segnali vengono utilizzati unicamente per innescare la procedura di cancellazione. In fase di avvio il server aggiunge alla propria maschera dei segnali \texttt{SIGINT} e \texttt{SIGTERM} invocando \texttt{pthread\_sigmask}: questo blocca la loro ricezione in ogni thread del server attivato successivamente; a questo punto viene attivato un nuovo thread -- \texttt{sig\_handler} -- che ha il compito di intercettare tali segnali in maniera sincrona invocando \texttt{sigwait}. Quando uno dei due segnali viene inviato al processo, \texttt{sig\_handler} si risveglia, ed invia richieste di cancellazione al \texttt{main} e a tutti i \texttt{client\_handler} in esecuzione, i cui identificatori sono memorizzati nella lista dei thread attivi.

Operazioni come l'inserimento di un nuovo thread nella lista, l'esecuzione di un comando sul file system e in generale qualunque frammento di codice che acquisisca un mutex, sono considerate sezioni critiche e sono protette dalla cancellazione. Le operazioni di clean-up (chiusura dei socket, rimozione dalla lista dei thread attivi) sono implementate installando nei thread dei \emph{clean-up handler} che vengono invocati all'uscita.

\section{Il processo client}
\label{sec:client}
Il client realizza una semplice interfaccia a riga di comando verso il server e viene lanciato con il comando
\begin{center}
\texttt{fats\_client usr [device]}
\end{center}
dove \texttt{usr} indica un nome utente e l'argomento opzionale \texttt{device} specifica il nome del device sul quale si vuole operare.

In fase di avvio il client invia al server una richiesta di connessione \texttt{MSG\_CONNECT} specificando nel
buffer il nome utente e l'eventuale device richiesto.

Una volta avviata la sessione con il server, viene lanciato un thread \texttt{server\_listener} che si occupa di stampare a video i messaggi di risposta ricevuti sul socket. Questo thread ha anche il compito di terminare l'esecuzione del client se il server per qualche motivo interrompe la conversazione (in questo caso la chiamata \texttt{receiveMessage} che viene invocata su un socket per ricevere un messaggio restituisce il valore \texttt{SEOF}).

La gestione dell'input dell'utente è invece compito del thread principale. La funzione \texttt{handle\_input} memorizza la stringa in ingresso in un array allocato staticamente e la passa alla funzione \texttt{parse\_cmd} che ha il compito di identificare il comando specificato e, in caso sia valido, convertirlo in un \texttt{message\_t} opportuno che viene poi inviato al server. Dal momento che il buffer in cui l'input è memorizzato ha dimensione fissa (definita dalla macro \texttt{MAXLINE} in \texttt{client\_impl.h}), esiste un limite sul numero di caratteri che possono costituire un comando; questo limita ad esempio la quantità di caratteri scrivibili su un file da una singola invocazione del comando \texttt{fats\_append}.

\section{Compilazione del sistema}
\label{sec:comp}
Il sistema si compila dalla root directory del progetto utilizzando l'utility \texttt{make}. I target del Makefile rilevanti ai fini della compilazione del sistema sono \texttt{build}, che compila il sistema ed elimina i file temporanei generati (file oggetto, etc \ldots) e \texttt{test}, che esegue alcuni semplici test di funzionamento del sistema e ne riporta l'esito sul terminale.

L'invocazione del comando `\texttt{make build}' genera gli eseguibili \texttt{fats\_create}, \texttt{fats\_server} e \texttt{fats\_client}.

Quando viene lanciato, il server crea il socket di connessione nella cartella
locale \texttt{tmp}.

\subsection{Il client \texttt{fats}}

I comandi del client vengono invocati esclusivamente su percorsi assoluti. La
sintassi dei comandi e' la seguente
\begin{description}
  \item[\texttt{mkdir dir}] \hfill \\
    Crea la cartella \texttt{dir}, se alcuni elementi intermedi del percorso non esistono l'operazione fallisce
  \item[\texttt{mkfile file}] \hfill \\
    Crea il file \texttt{file}, se alcuni elementi intermedi del percorso non esistono l'operazione fallisce
  \item[\texttt{ls dir}] \hfill \\
    Elenca il contenuto della cartella \texttt{dir}
  \item[\texttt{append file "string"}] \hfill \\
    Aggiunge in coda al file \texttt{file} il contenuto di \texttt{string}, escludendo gli apici che la delimitano
  \item[\texttt{fread file offset len}] \hfill \\
    Legge \texttt{len} caratteri di \texttt{file} a partire da \texttt{offset} e li stampa a video
  \item[\texttt{cp source dest}] \hfill \\
    Crea il file \texttt{dest} e vi copia per intero il contenuto di \texttt{source}
  \item[\texttt{quit}] \hfill \\
    Interrompe la conversazione con il server ed esce dal programma
\end{description}
In caso di fallimento di un'operazione viene stampato sullo schermo un messaggio che descrive l'errore notificato dal server.

\subsection{Test del sistema}

Il test del sistema e' effettuato invocando il comando `\texttt{make test}' e consiste nell'esecuzione di alcune operazioni dimostrative, e nel confronto delle risposte del server con quelle attese. I file usati dai test sono contenuti nella cartella \texttt{test}: i comandi sono letti dai file \texttt{test*.input}, e le risposte del server sono confrontate con i risultati salvati nei file \texttt{test*.ok} . Il target \texttt{test} del Makefile invoca quattro target (\texttt{test1}, \texttt{test2}, \texttt{test3}, \texttt{test4}) il cui compito e' quello di testare il funzionamento del sistema con file system che usano ogni dimensione di blocchi ammessa. I test consistono ciascuno nell'esecuzione di uno script shell che crea un file system, attiva un server fats, invoca le operazioni di prova salvando le risposte del server in \texttt{test/test*.output} per ogni run \texttt{test/test*.input}, confronta queste con i risultati attesi, notifica l'esito dei test all'utente e termina il server fats.

I run di prova simulano una semplice sessione:
\begin{itemize}
  \item \texttt{test1x.input} verificano che le cartelle e i file vengano creati e listati correttamente
  \item \texttt{test2x.input} verificano la correttezza delle operazioni di scrittura e di lettura
  \item \texttt{test3x.input} verificano la correttezza delle operazioni di copia
\end{itemize}

La creazione di cartelle genera una directory table con dimensione maggiore di un singolo blocco; la scrittura e la copia interessano files con un'estensione di due blocchi. Nei test viene utilizzata una versione del client che attende 2 secondi dopo la ricezione del comando \texttt{quit} per assicurarsi di ricevere le risposte dal server prima di chiudere la comunicazione.

% FINE DOCUMENTO
\end{document}