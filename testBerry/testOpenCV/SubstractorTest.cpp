#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cv.h>
#include <opencv2/video/background_segm.hpp>
#include <highgui.h>
#include <RaspiCamCV.h>
#include <fcntl.h>
#include <fstream>

#include<time.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pthread.h>

using namespace std;
using namespace cv;

Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;
int sockfd;
int initialTime;

//dichiarazioni di funzione
void *processVideo(void*);
void testMask(Vec3b &binPixel, bool condition);
int connectToServer();
void client(const char* server_address, const char id, short server_port);

int readInt;
bool ifThread;

int main()
{
  ifstream fileReader;
  fileReader.open("/home/pi/Desktop/Libscv/testOpenCVRelease/Config.txt");
  char indIp[25];
  char id;
  if(fileReader.is_open()) {
        fileReader >> indIp;
        fileReader >> id;
  }
  fileReader.close();
  client(indIp, id, 17171);
  return EXIT_SUCCESS;
}
void client(const char* server_address, const char id, short server_port)
{
     struct sockaddr_in servaddr;
     bool connection;
     ifThread = false;
     while (true) {

         sockfd = socket(AF_INET, SOCK_STREAM, 0);
         memset(&servaddr, 0x00, sizeof(servaddr));
         servaddr.sin_family = AF_INET;
         servaddr.sin_port = htons(server_port);
         inet_pton(AF_INET, server_address, &servaddr.sin_addr);
         fcntl(sockfd, F_SETFL, O_NONBLOCK);
         connection = false;
         while (!connection)
             if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
                sleep(10);
             }
             else{
                 connection = true;
                 cout << "Connessione stabilita" << endl;
             }
         char ReadBuffer[512];
         memset(ReadBuffer, 0x00, 512);
         recv(sockfd, ReadBuffer, sizeof(ReadBuffer), 0);
         ostringstream line;
         line << "Berry:"<< id << endl;
         send(sockfd, line.str().c_str(), line.str().length(), 0);
         readInt = 0;
         fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) & ~O_NONBLOCK);
         //initialTime = time(0);
         if(!ifThread) {
             pthread_t scanVideo;
             pthread_create(&scanVideo, NULL, &processVideo, NULL);
         }

         while(1)
         {
             int n = recv(sockfd, ReadBuffer, sizeof(ReadBuffer), 0);

             if(n <= 0)
             {
                 cout << "Server disconnesso" << endl;
                 close(sockfd);
                 readInt = 0;
                 break;
             }
             //possono essere ricevuti due stati: 1 per la disattivazione del thread di scansione, 2 per la sua riattivazione
             readInt = atoi(ReadBuffer);
             cout << readInt << endl;
             if (readInt > 5 && readInt < 11) {
                 initialTime = time(0);
                 readInt -= 5;
             }
             //cout << readInt << endl;
             if (readInt < 0 || readInt > 15)
                 cout << "Messaggio Errato" << endl;

         }
         sleep(5);
    }

 }

void *processVideo(void*) {

  ifThread = true;
  //creazione le finestre
  /*namedWindow("Frame");
  namedWindow("FG Mask MOG 2");
  namedWindow("ErosedImg");*/
  //namedWindow("Black");
  //creazione oggetto Background Subtractor
  pMOG2 = new BackgroundSubtractorMOG2(100, 3, false);
  Point pt1, pt2;
  cout << "Fase di Scansione avviata" << endl;
  RaspiCamCvCapture * capture = raspiCamCvCreateCameraCapture(0);

  //invio dell'immagine iniziale
  /*vector<int> params;
  vector<uchar> buff;
  params.push_back(CV_IMWRITE_JPEG_QUALITY);
  params.push_back(10);
  Mat firstframe(raspiCamCvQueryFrame(capture));
  imencode(".jpeg", firstframe, buff, params);
  cout << buff.size() << endl;
  send(sockfd, (const char*)buff.size(), sizeof(int), 0);
  send(sockfd, &buff, buff.size(), 0);
  */

  while(true){
      while( (char)keyboard != 'q' && (char)keyboard != 27 && readInt != 0){

        Mat frame(raspiCamCvQueryFrame(capture));
        Mat frameResized, /*frameHsv,*/ binMat;
        Size size(300, 220);
        resize(frame, frameResized, size);
        pMOG2->operator()(frameResized, fgMaskMOG2, 0.02);
        cvtColor(frameResized, binMat, CV_BGR2HSV);
        erode(fgMaskMOG2, fgMaskMOG2,getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
        //inRange(frameResized, Scalar(0, 0, 0), Scalar(180, 255, 40), frameHsv);
        for(int i = 0; i < binMat.rows; i++)
                     {
                         for(int j = 0; j < binMat.cols; j++)
                         {
                             bool condition = false;
                             Vec3b &binPixel = binMat.at<Vec3b>(i, j);
                             const unsigned char mogPixel = fgMaskMOG2.at<unsigned char> (i, j);
                             switch (readInt) {

                             case 1: condition = binPixel.val[2] < 40 && mogPixel >= 150; //Nero
                                     break;

                             case 2: condition = binPixel.val[0] < 6 && mogPixel >= 150; //Rosso
                                     break;

                             case 3: condition = binPixel.val[0] > 80 && binPixel.val[0] < 90 && binPixel.val[1] > 40 && mogPixel >= 150; //Verde
                                     break;

                             case 4: condition = binPixel.val[0] > 15 && binPixel.val[0] < 40 && binPixel.val[1] > 113 && mogPixel >= 150; //Giallo
                                     break;

                             case 5: condition = binPixel.val[1] > 30 && binPixel.val[2] > 90 && mogPixel >= 150; //Bianco
                                     break;

                             }
                             testMask(binPixel, condition);
                         }
                     }
        vector<vector<Point>> areas;
        Mat contourImg;
        unsigned int maxArea = 0;
        int index = 0;

        dilate(binMat, binMat, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
        erode(binMat, binMat, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
        cvtColor(binMat, contourImg, CV_RGB2GRAY);
        findContours(contourImg, areas, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);
        if(areas.size() > 0) {
            for(unsigned int i = 0; i < areas.size(); i++) {
                if(maxArea < areas.at(i).size()) {
                    maxArea = areas.at(i).size();
                    index = i;
                }
            }
            Rect rect = boundingRect(areas.at(index));
            pt1.x = rect.x;
            pt1.y = rect.y;
            pt2.x = rect.x + rect.width;
            pt2.y = rect.y + rect.height;
            rectangle(binMat, pt1, pt2, CV_RGB(255, 0, 0), 1);
            if(time(0) - initialTime > 30) {    //Se Ã¨ passato il tempo di configurazione mando le coordinate
                ostringstream ss;
                ss << "<p1>" << pt1.x << "</p1><p2>" << pt1.y << "</p2><p3>" << pt2.x << "</p3><p4>" << pt2.y << "</p4>" << endl;
                send(sockfd, ss.str().c_str(), ss.str().length(), 0);
                }

        }
        cvtColor(binMat, binMat, CV_HSV2BGR);
        //Visualizza le finestre
        /*imshow("ErosedImg", binMat);
        //imshow("Black", frameHsv);
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);*/
        //get the input from the keyboard
        keyboard = waitKey( 1 );
      }
    sleep(1);
   }
  cout << "Scansione Terminata" << endl;
  //delete capture object
  raspiCamCvReleaseCapture(&capture);
  return NULL;
}

 void testMask(Vec3b &binPixel, bool condition) {

    if (condition )  {
           binPixel.val[0] = 0;
           binPixel.val[1] = 0;
           binPixel.val[2] = 255;

    }
    else {
        binPixel.val[0] = 0;
        binPixel.val[1] = 0;
        binPixel.val[2] = 0;
    }
}
